import java_cup.runtime.*;

/* Definindo alguns trechos de código que será utilizado no Analisador Sintático  */
scan with {: return scanner.next_token(); :};

parser code{: 	
				public AnalisadorSemantico semantico = new AnalisadorSemantico();
				
				public void report_error(String message, Object info){
					Symbol sym = (Symbol) info;
					throw new Error("Syntax ERROR in '"+sym.value+"' at line: "+(sym.left+1));
			  	} :};

/* Terminals (tokens returned by the scanner). */
terminal SELF;
terminal VOID;
terminal RESULT;
terminal AND;
terminal BODYCONTEXT;
terminal CONTEXT;
terminal DEF;
terminal DERIVE;
terminal ELSE;
terminal ENDIF;
terminal ENDPACKAGE;
terminal IF;
terminal IMPLIES;
terminal IN;
terminal INIT;
terminal INV;
terminal LET;
terminal NOT;
terminal OR;
terminal PACKAGE;
terminal POST;
terminal PRE;
terminal ATPRE;
terminal THEN;
terminal XOR;
terminal TRUE;
terminal FALSE;
terminal DOUBLEPOINT;
terminal POINT_VIRGULA;
terminal DDOUBLEPOINT;
terminal VIRGULA;
terminal ARROW;
terminal PIPELINE;
terminal COLLECTION;
terminal IDENTIFIER;
terminal INTEGER_LITERAL;
terminal FLOAT_LITERAL;
terminal POINT;
terminal EQ;
terminal MINUS;
terminal MULTIPLY;
terminal DIVIDE;
terminal MOD;
terminal LESSTHAN;
terminal GREATERTHAN;
terminal NOTEQ;
terminal LESSEQTHAN;
terminal GREATEREQTHAN;
terminal PLUS;
terminal LEFTPARENTHESIS;
terminal RIGHTPARENTHESIS;
terminal LEFTBRACK;
terminal RIGHTBRACK;
terminal LEFTBRACKET;
terminal RIGHTBRACKET;
terminal STRING_LITERAL;


/* Non terminals */
non terminal            oclFile, packageName, oclExpressions,constraint,contextDeclaration,classifierContext,
					operationContext, operationName, formalParameterList, typeSpecifier,
					collectionType, oclExpression, returnType, expression, logicalExpression, 
					relationalExpression, additiveExpression, multiplicativeExpression, qualifiers, 
					unaryExpression, postfixExpression, primaryExpression, propertyCall, propertyCallParameters, 
					literal, simpleTypeSpecifier, literalCollection, collectionItem, declarator, 
					pathName, timeExpression, actualParameterList, collectionKind, relationalOperator, 
					addOperator, multiplyOperator, unaryOperator, logicalOperator, number, 
					
					oclFileAux, oclFileAuxLoopWithOne, oclFileAuxLoop, 
					
					oclExpressionsAux, 
					
					constraintAux, constraintAux2, constraintAux3, constraintAux2LoopWithOne, constraintAux2Loop, 
					
					contextDeclarationAux, 
					
					classifierContextAux, 
					
					operationContextAux, 
					
					formalParameterListAux2, formalParameterListAux, formalParameterListAuxLoop, 
					
					logicalExpressionAux, logicalExpressionAuxLoop, 
					
					relationalExpressionAux, 
					
					additiveExpressionAux, additiveExpressionAuxLoop, 
					
					multiplicativeExpressionAux, multiplicativeExpressionAuxLoop, 
					
					unaryExpressionAux, 
					
					postfixExpressionAux, postfixExpressionAux2, postfixExpressionAux2Loop, 
					
					propertyCallParametersAux, propertyCallParametersAux2, 
					
					literalCollectionAux, literalCollectionAux2, literalCollectionAuxLoop, 
					
					collectionItemAux, 
					
					propertyCallAux, propertyCallAux2, propertyCallAux3, 
					
					declaratorAux, declaratorAuxLoop, declaratorAux2, declaratorAux3, 
					
					pathNameAux, pathNameAuxLoop, 
					
					actualParameterListAux, actualParameterListAuxLoop, 
					
					booleanLiteral, 
					
					ifExpression;

/* Precedences */

precedence left VIRGULA;
precedence left IMPLIES;
precedence left NOT;
precedence left AND;
precedence left OR;
precedence left XOR;
precedence left EQ, NOTEQ;
precedence left LESSTHAN, GREATERTHAN, GREATEREQTHAN, LESSEQTHAN;
precedence left IF, THEN, ELSE, ENDIF;
precedence left PLUS, MINUS;
precedence left MULTIPLY, DIVIDE, MOD;
precedence left NOT;
precedence left POINT, ARROW, IDENTIFIER;
precedence left ATPRE;


/* The grammar */

/* oclFile ::= ( PACKAGE packageName oclExpressions ENDPACKAGE )+; */

oclFile ::= oclFileAuxLoopWithOne | oclExpressions;

oclFileAux ::= PACKAGE packageName oclExpressions ENDPACKAGE;

oclFileAuxLoopWithOne ::= oclFileAux oclFileAuxLoop;

oclFileAuxLoop ::= oclFileAux oclFileAuxLoop | ;



packageName ::= pathName;



/* oclExpressions ::= ( constraint )*; */

oclExpressions ::= oclExpressionsAux;

oclExpressionsAux ::= constraint oclExpressionsAux | ;


/* constraint ::= contextDeclaration( (PRE|POST) IDENTIFIER? DOUBLEPOINT oclExpression)+; */

constraint ::= contextDeclaration constraintAux2LoopWithOne;

constraintAux2 ::= constraintAux constraintAux3 DOUBLEPOINT oclExpression;
				
constraintAux ::= PRE  {: parser.semantico.setStereotype("pre"); :} | POST  {: parser.semantico.setStereotype("post"); :};

constraintAux2LoopWithOne ::= constraintAux2 constraintAux2Loop;

constraintAux2Loop ::= constraintAux2 constraintAux2Loop | ;

constraintAux3 ::= IDENTIFIER | ;


/* contextDeclaration ::= CONTEXT ( operationContext ); */

contextDeclaration ::= CONTEXT contextDeclarationAux;

contextDeclarationAux ::= operationContext;


/* operationContext ::= IDENTIFIER DDOUBLEPOINT operationName LEFTPARENTHESIS formalParameterList RIGHTPARENTHESIS ( DOUBLEPOINT returnType )?; */

operationContext ::= IDENTIFIER DDOUBLEPOINT operationName LEFTPARENTHESIS formalParameterList RIGHTPARENTHESIS operationContextAux;

operationContextAux ::= DOUBLEPOINT returnType | ;



ifExpression ::= IF expression THEN expression ELSE expression ENDIF;




operationName ::= IDENTIFIER | EQ | PLUS | MINUS | LESSTHAN | GREATEREQTHAN |
					IMPLIES | NOT | OR | XOR | AND | LESSEQTHAN | GREATERTHAN | DIVIDE | MULTIPLY | NOTEQ | MOD;
					
					
/* formalParameterList ::= ( IDENTIFIER DOUBLEPOINT typeSpecifier (VIRGULA IDENTIFIER DOUBLEPOINT typeSpecifier )* )?; */
					
formalParameterList ::= formalParameterListAux2;

formalParameterListAux2 ::= IDENTIFIER DOUBLEPOINT typeSpecifier formalParameterListAuxLoop | ;

formalParameterListAux ::= VIRGULA IDENTIFIER DOUBLEPOINT typeSpecifier;

formalParameterListAuxLoop ::= formalParameterListAux formalParameterListAuxLoop | ;



typeSpecifier ::= simpleTypeSpecifier | collectionType;



collectionType ::= collectionKind LEFTPARENTHESIS simpleTypeSpecifier RIGHTPARENTHESIS;



oclExpression ::= expression;



returnType ::= typeSpecifier | VOID;



expression ::= logicalExpression;



/* logicalExpression ::= relationalExpression ( logicalOperator relationalExpression )*; */

logicalExpression ::= relationalExpression logicalExpressionAuxLoop;

logicalExpressionAux ::= logicalOperator relationalExpression;

logicalExpressionAuxLoop ::= logicalExpressionAux logicalExpressionAuxLoop | ;


/* relationalExpression ::= additiveExpression ( relationalOperator additiveExpression )?; */

relationalExpression ::= additiveExpression relationalExpressionAux;

relationalExpressionAux ::= relationalOperator additiveExpression | ;


/* additiveExpression ::= multiplicativeExpression ( addOperator multiplicativeExpression )*; */

additiveExpression ::= multiplicativeExpression additiveExpressionAuxLoop;

additiveExpressionAux ::= addOperator multiplicativeExpression;

additiveExpressionAuxLoop ::= additiveExpressionAux additiveExpressionAuxLoop | ;



/* multiplicativeExpression ::= unaryExpression ( multiplyOperator unaryExpression )*; */

multiplicativeExpression ::= unaryExpression multiplicativeExpressionAuxLoop;

multiplicativeExpressionAux ::= multiplyOperator unaryExpression;

multiplicativeExpressionAuxLoop ::= multiplicativeExpressionAux multiplicativeExpressionAuxLoop | ;




/* unaryExpression ::= ( unaryOperator postfixExpression ) | postfixExpression; */

unaryExpression ::= unaryExpressionAux | postfixExpression;

unaryExpressionAux ::= unaryOperator postfixExpression;




/* postfixExpression ::= primaryExpression ( (POINT | ARROW) propertyCall )*; */

postfixExpression ::= primaryExpression postfixExpressionAux2Loop;

postfixExpressionAux ::= POINT | ARROW;

postfixExpressionAux2 ::= postfixExpressionAux propertyCall;

postfixExpressionAux2Loop ::= postfixExpressionAux2 postfixExpressionAux2Loop | ;




primaryExpression ::= literalCollection | literal:lit1 {: RESULT = lit1; :} | propertyCall | LEFTPARENTHESIS expression RIGHTPARENTHESIS | SELF | SELF timeExpression  | ifExpression;



/* propertyCallParameters := LEFTPARENTHESIS ( declarator )? ( actualParameterList )? RIGHTPARENTHESIS; */



propertyCallParameters ::= LEFTPARENTHESIS propertyCallParametersAux propertyCallParametersAux2  RIGHTPARENTHESIS | LEFTPARENTHESIS propertyCallParametersAux2  RIGHTPARENTHESIS;

propertyCallParametersAux ::= declarator;

propertyCallParametersAux2 ::= actualParameterList | ;




booleanLiteral ::= TRUE:boolTrue {: RESULT = new Node(boolTrue,"Boolean"); :} 
					| FALSE:boolFalse {: RESULT = new Node(boolFalse,"Boolean"); :};

literal ::= STRING_LITERAL:litString {: RESULT = new Node(litString,"String"); :} 
			| number:litNum {: RESULT = litNum; :} 
			| booleanLiteral:litBool {: RESULT = litBool; :} 
			| RESULT:litResult {: parser.semantico.checkStereotype("result",litResultleft); :};



simpleTypeSpecifier ::= pathName;



/* literalCollection ::= collectionKind LEFTBRACKET ( collectionItem (VIRGULA collectionItem )* )? RIGHTBRACKET; */

literalCollection ::= collectionKind LEFTBRACKET literalCollectionAux2 RIGHTBRACKET;

literalCollectionAux ::= VIRGULA collectionItem;

literalCollectionAuxLoop ::= literalCollectionAux literalCollectionAuxLoop | ;

literalCollectionAux2 ::= collectionItem literalCollectionAuxLoop | ;



/* collectionItem ::= expression (POINT POINT expression )?; */

collectionItem ::= expression collectionItemAux;

collectionItemAux ::= POINT POINT expression | ;



/* propertyCall ::= pathName ( qualifiers )? ( propertyCallParameters )?; */

propertyCall ::= pathName propertyCallAux propertyCallAux2 propertyCallAux3;

propertyCallAux ::= timeExpression | ;

propertyCallAux2 ::= qualifiers | ;

propertyCallAux3 ::= propertyCallParameters | ;



qualifiers ::= LEFTBRACK actualParameterList RIGHTBRACK;



/* declarator ::= IDENTIFIER ( VIRGULA IDENTIFIER )* ( DOUBLEPOINT simpleTypeSpecifier )? ( POINT_VIRGULA IDENTIFIER POINT_VIRGULA typeSpecifier EQ expression )? PIPELINE ; */

declarator ::= IDENTIFIER declaratorAuxLoop declaratorAux2 declaratorAux3 PIPELINE ;

declaratorAux ::= VIRGULA IDENTIFIER;

declaratorAuxLoop ::= declaratorAux declaratorAuxLoop | ;

declaratorAux2 ::= DOUBLEPOINT simpleTypeSpecifier | ;

declaratorAux3 ::= POINT_VIRGULA IDENTIFIER POINT_VIRGULA typeSpecifier EQ expression | ;



pathName ::= IDENTIFIER pathNameAuxLoop;

pathNameAux ::= DDOUBLEPOINT IDENTIFIER;

pathNameAuxLoop ::= pathNameAux pathNameAuxLoop | ;



timeExpression ::= ATPRE:atPre {: parser.semantico.checkStereotype("@pre",atPreleft); :};



actualParameterList ::= expression actualParameterListAuxLoop;

actualParameterListAux ::= VIRGULA expression;

actualParameterListAuxLoop ::= actualParameterListAux actualParameterListAuxLoop | ;




collectionKind ::= COLLECTION;



relationalOperator ::= EQ {: RESULT = "="; :}  
						| GREATERTHAN  {: RESULT = ">"; :} 
						| LESSTHAN {: RESULT = "<"; :} 
						| GREATEREQTHAN {: RESULT = ">="; :}  
						| LESSEQTHAN {: RESULT = "<="; :}  
						| NOTEQ {: RESULT = "<>"; :} ;



addOperator ::= PLUS {: RESULT = "+"; :}  
				| MINUS  {: RESULT = "-"; :} 
				| MOD {: RESULT = "%"; :} ;



multiplyOperator ::= MULTIPLY {: RESULT = "*"; :}  
					| DIVIDE {: RESULT = "/"; :}  
					| MOD {: RESULT = "%"; :} ;



unaryOperator ::= MINUS {: RESULT = "-"; :} | NOT {: RESULT = "not"; :} ;



logicalOperator ::= AND {: RESULT = "and"; :} 
					| OR {: RESULT = "or"; :} 
					| XOR {: RESULT = "xor"; :} 
					| IMPLIES {: RESULT = "implies"; :};



number ::= INTEGER_LITERAL:numbInt {: RESULT = new Node(numbInt, "Integer"); :} | FLOAT_LITERAL:numbFloat {: RESULT = new Node(numbFloat, "Float"); :};