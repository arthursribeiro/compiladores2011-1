import java_cup.runtime.*;

/* Preliminaries to set up and use the scanner.  */
scan with {: return scanner.next_token(); :};

/* Terminals (tokens returned by the scanner). */
terminal            IDENTIFIER;
terminal            SELF;
terminal            RESULT;
terminal            AND;
terminal            BODYCONTEXT;
terminal            CONTEXT;
terminal            DEF;
terminal            DERIVE;
terminal            ELSE;
terminal            ENDIF;
terminal            ENDPACKAGE;
terminal            IF;
terminal            IMPLIES;
terminal            IN;
terminal            INIT;
terminal            INV;
terminal            LET;
terminal            NOT;
terminal            OR;
terminal            PACKAGE;
terminal            POST;
terminal            PRE;
terminal            ATPRE;
terminal            STATIC;
terminal            THEN;
terminal            XOR;
terminal            TRUE;
terminal            FALSE;
terminal			EQ;
terminal			MINUS;
terminal			MULTIPLY;
terminal			DIVIDE;
terminal			LESSTHAN;
terminal			GREATERTHAN;
terminal			NOTEQ;
terminal			LESSEQTHAN;
terminal			GREATEREQTHAN;
terminal			PLUS;
terminal			LEFTPARENTHESIS;
terminal			RIGHTPARENTHESIS;
terminal			LEFTBRACK;
terminal			RIGHTBRACK;
terminal			LEFTBRACKET;
terminal			RIGHTBRACKET;
terminal			MOD;
terminal			POINT;
terminal			DOUBLEPOINT;
terminal			ARROW;
terminal			VOID;
terminal			PIPELINE;
terminal			DDOUBLEPOINT;
terminal			VIRGULA;
terminal			COLLECTION;
terminal			POINT_VIRGULA;
terminal Integer    INTEGER_LITERAL;
terminal Double    	FLOAT_LITERAL;
terminal String		STRING_LITERAL;

/* Non terminals */
non terminal            oclFile, packageName, oclExpressions,constraint,contextDeclaration,classifierContext,
					operationContext, stereotype, operationName, formalParameterList, typeSpecifier,
					collectionType, oclExpression, returnType, expression, logicalExpression, 
					relationalExpression, additiveExpression, multiplicativeExpression, 
					unaryExpression, postfixExpression, primaryExpression, propertyCallParameters, 
					literal, simpleTypeSpecifier, literalCollection, collectionItem, declarator, 
					pathName, timeExpression, actualParameterList, collectionKind, relationalOperator, 
					addOperator, multiplyOperator, unaryOperator, logicalOperator, number;


/* Precedences */


/* The grammar */

oclFile ::= ( PACKAGE packageName oclExpressions ENDPACKAGE )+;

packageName ::= pathName;

oclExpressions ::= ( constraint )*;

constraint ::= contextDeclaration( stereotype IDENTIFIER? DOUBLEPOINT oclExpression)+;

contextDeclaration ::= CONTEXT ( operationContext | classifierContext );

classifierContext ::= (IDENTIFIER DOUBLEPOINT IDENTIFIER ) | IDENTIFIER;

operationContext ::= IDENTIFIER DDOUBLEPOINT operationName LEFTPARENTHESIS formalParameterList RIGHTPARENTHESIS ( DOUBLEPOINT returnType )?;

stereotype ::= ( PRE | POST );

operationName ::= IDENTIFIER | EQ | PLUS | MINUS | LESSTHAN | GREATEREQTHAN |
					IMPLIES | NOT | OR | XOR | AND | LESSEQTHAN | GREATERTHAN | DIVIDE | MULTIPLY | NOTEQ;
					
formalParameterList ::= ( IDENTIFIER DOUBLEPOINT typeSpecifier (VIRGULA IDENTIFIER DOUBLEPOINT typeSpecifier )* )?;

typeSpecifier ::= simpleTypeSpecifier | collectionType;

collectionType ::= collectionKind LEFTPARENTHESIS simpleTypeSpecifier RIGHTPARENTHESIS;

oclExpression ::= expression;

returnType ::= typeSpecifier;

expression ::= logicalExpression;

logicalExpression ::= relationalExpression ( logicalOperator relationalExpression )*;

relationalExpression ::= additiveExpression ( relationalOperator additiveExpression )?;

additiveExpression ::= multiplicativeExpression ( addOperator multiplicativeExpression )*;

multiplicativeExpression ::= unaryExpression ( multiplyOperator unaryExpression )*;

unaryExpression ::= ( unaryOperator postfixExpression ) | postfixExpression;

postfixExpression ::= primaryExpression ( (POINT | ARROW) propertyCall )*;

primaryExpression ::= literalCollection | literal | propertyCall | LEFTPARENTHESIS expression RIGHTPARENTHESIS;

propertyCallParameters := LEFTPARENTHESIS ( declarator )? ( actualParameterList )? RIGHTPARENTHESIS;

literal ::= STRING_LITERAL | FLOAT_LITERAL | INTEGER_LITERAL;

simpleTypeSpecifier ::= pathName;

literalCollection ::= collectionKind LEFTBRACKET ( collectionItem (VIRGULA collectionItem )* )? RIGHTBRACKET;

collectionItem ::= expression (POINT POINT expression )?;

propertyCall ::= pathName ( timeExpression )? ( qualifiers )? ( propertyCallParameters )?;

qualifiers ::= LEFTBRACK actualParameterList RIGHTBRACK;

declarator ::= IDENTIFIER ( VIRGULA IDENTIFIER )* ( DOUBLEPOINT simpleTypeSpecifier )? ( POINT_VIRGULA IDENTIFIER POINT_VIRGULA typeSpecifier EQ expression )? PIPELINE ;

pathName ::= IDENTIFIER ( DDOUBLEPOINT IDENTIFIER )*;

timeExpression ::= ATPRE;

actualParameterList ::= expression (VIRGULA expression)*;

collectionKind ::= COLLECTION;

relationalOperator ::= EQ | GREATERTHAN | LESSTHAN | GREATEREQTHAN | LESSEQTHAN | NOTEQ;

addOperator ::= PLUS | MINUS ;

multiplyOperator ::= MULTIPLY | DIVIDE;

unaryOperator ::= MINUS | NOT;

logicalOperator ::= AND | OR | XOR | IMPLIES;

number ::= INTEGER | FLOAT;