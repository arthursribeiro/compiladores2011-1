import java_cup.runtime.*;
import Semantica.ConteudoObjeto;
import Semantica.Node;

/* Definindo alguns trechos de código que será utilizado no Analisador Sintático  */
scan with {: return scanner.next_token(); :};

parser code{: 	
				public AnalisadorSemantico semantico = new AnalisadorSemantico();
				
				public void report_error(String message, Object info){
					Symbol sym = (Symbol) info;
					throw new Error("Syntax ERROR in '"+sym.value+"' at line: "+(sym.left+1));
			  	} :};

/* Terminals (tokens returned by the scanner). */
terminal SELF;
terminal VOID;
terminal RESULT;
terminal AND;
terminal BODYCONTEXT;
terminal CONTEXT;
terminal DEF;
terminal DERIVE;
terminal ELSE;
terminal ENDIF;
terminal ENDPACKAGE;
terminal IF;
terminal IMPLIES;
terminal IN;
terminal INIT;
terminal INV;
terminal LET;
terminal NOT;
terminal OR;
terminal PACKAGE;
terminal POST;
terminal PRE;
terminal ATPRE;
terminal THEN;
terminal XOR;
terminal TRUE;
terminal FALSE;
terminal DOUBLEPOINT;
terminal POINT_VIRGULA;
terminal DDOUBLEPOINT;
terminal VIRGULA;
terminal ARROW;
terminal PIPELINE;
terminal COLLECTION;
terminal IDENTIFIER;
terminal INTEGER_LITERAL;
terminal FLOAT_LITERAL;
terminal POINT;
terminal EQ;
terminal MINUS;
terminal MULTIPLY;
terminal DIVIDE;
terminal MOD;
terminal LESSTHAN;
terminal GREATERTHAN;
terminal NOTEQ;
terminal LESSEQTHAN;
terminal GREATEREQTHAN;
terminal PLUS;
terminal LEFTPARENTHESIS;
terminal RIGHTPARENTHESIS;
terminal LEFTBRACK;
terminal RIGHTBRACK;
terminal LEFTBRACKET;
terminal RIGHTBRACKET;
terminal STRING_LITERAL;


/* Non terminals */
non terminal            oclFile, packageName, oclExpressions,constraint,contextDeclaration,classifierContext,
					operationContext, operationName, formalParameterList, typeSpecifier,
					collectionType, oclExpression, returnType, expression, logicalExpression, 
					relationalExpression, additiveExpression, multiplicativeExpression, qualifiers, 
					unaryExpression, postfixExpression, primaryExpression, propertyCall, propertyCallParameters, 
					literal, simpleTypeSpecifier, literalCollection, collectionItem, declarator, 
					pathName, timeExpression, actualParameterList, collectionKind, relationalOperator, 
					addOperator, multiplyOperator, unaryOperator, logicalOperator, number, 
					
					oclFileAux, oclFileAuxLoopWithOne, oclFileAuxLoop, 
					
					oclExpressionsAux, 
					
					constraintAux, constraintAux2, constraintAux3, constraintAux2LoopWithOne, constraintAux2Loop, 
					
					contextDeclarationAux, 
					
					classifierContextAux, 
					
					operationContextAux, 
					
					formalParameterListAux2, formalParameterListAux, formalParameterListAuxLoop, 
					
					logicalExpressionAux, logicalExpressionAuxLoop, 
					
					relationalExpressionAux, 
					
					additiveExpressionAux, additiveExpressionAuxLoop, 
					
					multiplicativeExpressionAux, multiplicativeExpressionAuxLoop, 
					
					unaryExpressionAux, 
					
					postfixExpressionAux, postfixExpressionAux2, postfixExpressionAux2Loop, 
					
					propertyCallParametersAux, propertyCallParametersAux2, 
					
					literalCollectionAux, literalCollectionAux2, literalCollectionAuxLoop, 
					
					collectionItemAux, 
					
					propertyCallAux, propertyCallAux2, propertyCallAux3, 
					
					declaratorAux, declaratorAuxLoop, declaratorAux2, declaratorAux3, 
					
					pathNameAux, pathNameAuxLoop, 
					
					actualParameterListAux, actualParameterListAuxLoop, 
					
					booleanLiteral, 
					
					ifExpression;

/* Precedences */

precedence left VIRGULA;
precedence left IMPLIES;
precedence left NOT;
precedence left AND;
precedence left OR;
precedence left XOR;
precedence left EQ, NOTEQ;
precedence left LESSTHAN, GREATERTHAN, GREATEREQTHAN, LESSEQTHAN;
precedence left IF, THEN, ELSE, ENDIF;
precedence left PLUS, MINUS;
precedence left MULTIPLY, DIVIDE, MOD;
precedence left NOT;
precedence left POINT, ARROW, IDENTIFIER;
precedence left ATPRE;


/* The grammar */

/* oclFile ::= ( PACKAGE packageName oclExpressions ENDPACKAGE )+; */

oclFile ::= oclFileAuxLoopWithOne | oclExpressions;

oclFileAux ::= PACKAGE packageName oclExpressions ENDPACKAGE;

oclFileAuxLoopWithOne ::= oclFileAux oclFileAuxLoop;

oclFileAuxLoop ::= oclFileAux oclFileAuxLoop | ;



packageName ::= pathName;



/* oclExpressions ::= ( constraint )*; */

oclExpressions ::= oclExpressionsAux;

oclExpressionsAux ::= constraint oclExpressionsAux | ;


/* constraint ::= contextDeclaration( (PRE|POST) IDENTIFIER? DOUBLEPOINT oclExpression)+; */

constraint ::= contextDeclaration constraintAux2LoopWithOne;

constraintAux2 ::= constraintAux constraintAux3 DOUBLEPOINT oclExpression;
				
constraintAux ::= PRE  {: parser.semantico.setStereotype("pre"); :} | POST  {: parser.semantico.setStereotype("post"); :};

constraintAux2LoopWithOne ::= constraintAux2 constraintAux2Loop;

constraintAux2Loop ::= constraintAux2 constraintAux2Loop | ;

constraintAux3 ::= IDENTIFIER | ;


/* contextDeclaration ::= CONTEXT ( operationContext ); */

contextDeclaration ::= CONTEXT contextDeclarationAux;

contextDeclarationAux ::= operationContext;


/* operationContext ::= IDENTIFIER DDOUBLEPOINT operationName LEFTPARENTHESIS formalParameterList RIGHTPARENTHESIS ( DOUBLEPOINT returnType )?; */

operationContext ::= IDENTIFIER DDOUBLEPOINT operationName LEFTPARENTHESIS formalParameterList RIGHTPARENTHESIS operationContextAux;

operationContextAux ::= DOUBLEPOINT returnType | ;



ifExpression ::= IF expression THEN expression ELSE expression ENDIF;




operationName ::= IDENTIFIER | EQ | PLUS | MINUS | LESSTHAN | GREATEREQTHAN |
					IMPLIES | NOT | OR | XOR | AND | LESSEQTHAN | GREATERTHAN | DIVIDE | MULTIPLY | NOTEQ | MOD;
					
					
/* formalParameterList ::= ( IDENTIFIER DOUBLEPOINT typeSpecifier (VIRGULA IDENTIFIER DOUBLEPOINT typeSpecifier )* )?; */
					
formalParameterList ::= formalParameterListAux2;

formalParameterListAux2 ::= IDENTIFIER DOUBLEPOINT typeSpecifier formalParameterListAuxLoop | ;

formalParameterListAux ::= VIRGULA IDENTIFIER DOUBLEPOINT typeSpecifier;

formalParameterListAuxLoop ::= formalParameterListAux formalParameterListAuxLoop | ;



typeSpecifier ::= simpleTypeSpecifier | collectionType;



collectionType ::= collectionKind LEFTPARENTHESIS simpleTypeSpecifier RIGHTPARENTHESIS;



oclExpression ::= expression;



returnType ::= typeSpecifier | VOID;



expression ::= logicalExpression;



/* logicalExpression ::= relationalExpression ( logicalOperator relationalExpression )*; */

logicalExpression ::= relationalExpression logicalExpressionAuxLoop;

logicalExpressionAux ::= logicalOperator relationalExpression;

logicalExpressionAuxLoop ::= logicalExpressionAux logicalExpressionAuxLoop | ;


/* relationalExpression ::= additiveExpression ( relationalOperator additiveExpression )?; */

relationalExpression ::= additiveExpression relationalExpressionAux;

relationalExpressionAux ::= relationalOperator additiveExpression | ;


/* additiveExpression ::= multiplicativeExpression ( addOperator multiplicativeExpression )*; */

additiveExpression ::= multiplicativeExpression:m1 additiveExpressionAuxLoop:a1 {: if(a1 == null) {
                                                                                       RESULT = ((ConteudoObjeto)m1);
                                                                                   } else {
                                                                                       String tipo;
                                                                                       ConteudoObjeto c1, c2;
                                                                                       c1 = ((ConteudoObjeto)m1);
                                                                                       c2 = ((ConteudoObjeto)a1);
                                                                                       if(c1.getTipo().equals("int") && c2.getTipo().equals("int")){
                                                                                           tipo = "int";
                                                                                       } else if (c1.getTipo().equals("int") && c2.getTipo().equals("float")) {
                                                                                           tipo = "float";
                                                                                       } else if (c1.getTipo().equals("float") && c2.getTipo().equals("int")) {
                                                                                           tipo = "float";
                                                                                       } else if (c1.getTipo().equals("float") && c2.getTipo().equals("float")) {
                                                                                           tipo = "float";
                                                                                       } else {
                                                                                           throw new Exception("Nao eh permitido somar " + c1.getTipo() + " com " + c2.getTipo());
                                                                                       }
                                                                                   } :};

additiveExpressionAux ::= addOperator multiplicativeExpression;

additiveExpressionAuxLoop ::= additiveExpressionAux additiveExpressionAuxLoop | ;



/* multiplicativeExpression ::= unaryExpression ( multiplyOperator unaryExpression )*; */

multiplicativeExpression ::= unaryExpression:ue multiplicativeExpressionAuxLoop:meal {: if(meal == null) {
                                                                                            RESULT = ((ConteudoObjeto)ue);
                                                                                        } else {
                                                                                            String tipo = null;
                                                                                            ConteudoObjeto c1, c2;
                                                                                            c1 = ((ConteudoObjeto)ue);
                                                                                            c2 = ((ConteudoObjeto)meal);
                                                                                            if(c1.getTipo().equals("int") && c2.getTipo().equals("int")){
                                                                                                tipo = "int";
                                                                                            } else if (c1.getTipo().equals("int") && c2.getTipo().equals("float")) {
                                                                                                tipo = "float";
                                                                                            } else if (c1.getTipo().equals("float") && c2.getTipo().equals("int")) {
                                                                                                tipo = "float";
                                                                                            } else if (c1.getTipo().equals("float") && c2.getTipo().equals("float")) {
                                                                                                tipo = "float";
                                                                                            } else {
                                                                                                System.err.println("Nao eh permitido somar " + c1.getTipo() + " com " + c2.getTipo());
                                                                                            }
                                                                                            RESULT = new ConteudoObjeto(tipo, null);
                                                                                        } :};

multiplicativeExpressionAux ::= multiplyOperator unaryExpression:ue {: RESULT = ((ConteudoObjeto)ue); :};

multiplicativeExpressionAuxLoop ::= multiplicativeExpressionAux:mea multiplicativeExpressionAuxLoop:meal {: if(meal == null) {
                                                                                                                RESULT = ((ConteudoObjeto)mea);
                                                                                                            } else {
                                                                                                                String tipo = null;
		 	                                                                                                    ConteudoObjeto c1, c2;
		 	                                                                                                    c1 = ((ConteudoObjeto)mea);
		 	                                                                                                    c2 = ((ConteudoObjeto)meal);
		 	                                                                                                    if(c1.getTipo().equals("int") && c2.getTipo().equals("int")){
		 	                                                                                                        tipo = "int";
		 	                                                                                                    } else if (c1.getTipo().equals("int") && c2.getTipo().equals("float")) {
		 	                                                                                                        tipo = "float";
		 	                                                                                                    } else if (c1.getTipo().equals("float") && c2.getTipo().equals("int")) {
		 	                                                                                                        tipo = "float";
		 	                                                                                                    } else if (c1.getTipo().equals("float") && c2.getTipo().equals("float")) {
		 	                                                                                                        tipo = "float";
		 	                                                                                                    } else {
		 	                                                                                                        System.err.println("Nao eh permitido somar " + c1.getTipo() + " com " + c2.getTipo());
		 	                                                                                                    }
		 	                                                                                                    RESULT = new ConteudoObjeto(tipo, null);
			                                                                                                } :} 
                                  | {: RESULT = null; :} ;




/* unaryExpression ::= ( unaryOperator postfixExpression ) | postfixExpression; */

unaryExpression ::= unaryExpressionAux:uea {: RESULT = ((ConteudoObjeto)uea); :} 
                  | postfixExpression:pe {: RESULT = ((ConteudoObjeto)pe); :};

unaryExpressionAux ::= unaryOperator postfixExpression:pe {: RESULT = ((ConteudoObjeto)pe); :};




/* postfixExpression ::= primaryExpression ( (POINT | ARROW) propertyCall )*; */

postfixExpression ::= primaryExpression postfixExpressionAux2Loop;

postfixExpressionAux ::= POINT | ARROW;

postfixExpressionAux2 ::= postfixExpressionAux propertyCall;

postfixExpressionAux2Loop ::= postfixExpressionAux2 postfixExpressionAux2Loop | ;




primaryExpression ::= literalCollection | 
					  literal:lit1 {: RESULT = lit1; :} 
					  | propertyCall 
					  | LEFTPARENTHESIS expression:e1 RIGHTPARENTHESIS {: RESULT = e1; :} 
					  | SELF 
					  | SELF timeExpression  
					  | ifExpression;


/* propertyCallParameters := LEFTPARENTHESIS ( declarator )? ( actualParameterList )? RIGHTPARENTHESIS; */



propertyCallParameters ::= LEFTPARENTHESIS propertyCallParametersAux propertyCallParametersAux2:prop1  RIGHTPARENTHESIS {: System.out.println("Tratar declarator"); :}| 
							LEFTPARENTHESIS propertyCallParametersAux2:prop2  RIGHTPARENTHESIS{: RESULT = prop2;:};

propertyCallParametersAux ::= declarator {: System.out.println("Tratar declarator"); :};

propertyCallParametersAux2 ::= actualParameterList:a1 {: RESULT = (Node)a1;:}
								|{: Node resultado = new Node();
									resultado.setType("void");
									RESULT = resultado; :} ;




booleanLiteral ::= TRUE:boolTrue {: RESULT = new ConteudoObjeto("Boolean",boolTrue); :} 
					| FALSE:boolFalse {: RESULT = new ConteudoObjeto("Boolean",boolFalse); :};

literal ::= STRING_LITERAL:litString {: RESULT = new ConteudoObjeto("String",litString); :} 
			| number:litNum {: RESULT = (ConteudoObjeto)litNum; :} 
			| booleanLiteral:litBool {: RESULT = (ConteudoObjeto)litBool; :} 
			| RESULT:litResult {: parser.semantico.checkStereotype("result",litResultleft); :};


simpleTypeSpecifier ::= pathName;



/* literalCollection ::= collectionKind LEFTBRACKET ( collectionItem (VIRGULA collectionItem )* )? RIGHTBRACKET; */

literalCollection ::= collectionKind LEFTBRACKET literalCollectionAux2 RIGHTBRACKET;

literalCollectionAux ::= VIRGULA collectionItem;

literalCollectionAuxLoop ::= literalCollectionAux literalCollectionAuxLoop | ;

literalCollectionAux2 ::= collectionItem literalCollectionAuxLoop | ;



/* collectionItem ::= expression (POINT POINT expression )?; */

collectionItem ::= expression collectionItemAux;

collectionItemAux ::= POINT POINT expression | ;



/* propertyCall ::= pathName ( qualifiers )? ( propertyCallParameters )?; */

propertyCall ::= pathName propertyCallAux propertyCallAux2 propertyCallAux3;

propertyCallAux ::= timeExpression | ;

propertyCallAux2 ::= qualifiers:q1 {: RESULT = q1; :} 
					 | {: RESULT = null; :};

propertyCallAux3 ::= propertyCallParameters:prop1 {: RESULT = prop1; :}  
					|{: RESULT = null; :} ;



qualifiers ::= LEFTBRACK actualParameterList:a1 RIGHTBRACK {: RESULT = (Node)a1; :};



/* declarator ::= IDENTIFIER ( VIRGULA IDENTIFIER )* ( DOUBLEPOINT simpleTypeSpecifier )? ( POINT_VIRGULA IDENTIFIER POINT_VIRGULA typeSpecifier EQ expression )? PIPELINE ; */

declarator ::= IDENTIFIER declaratorAuxLoop declaratorAux2 declaratorAux3 PIPELINE ;

declaratorAux ::= VIRGULA IDENTIFIER;

declaratorAuxLoop ::= declaratorAux declaratorAuxLoop | ;

declaratorAux2 ::= DOUBLEPOINT simpleTypeSpecifier | ;

declaratorAux3 ::= POINT_VIRGULA IDENTIFIER POINT_VIRGULA typeSpecifier EQ expression | ;



pathName ::= IDENTIFIER pathNameAuxLoop;

pathNameAux ::= DDOUBLEPOINT IDENTIFIER;

pathNameAuxLoop ::= pathNameAux pathNameAuxLoop | ;



timeExpression ::= ATPRE:atPre {: parser.semantico.checkStereotype("@pre",atPreleft); :};



actualParameterList ::= expression:e1 actualParameterListAuxLoop:aloop {: Node resultado;
																		if(aloop == null){
																			resultado = (Node)e1;
																		}
																		else{
																			resultado = new Node();
																			resultado.addElement((Node)e1);
																			resultado.addAllElements(((Node) aloop).getElements());}
																			RESULT = resultado; :};

actualParameterListAux ::= VIRGULA expression:e1 {: RESULT = (Node)e1;:};

actualParameterListAuxLoop ::= actualParameterListAux:a1 actualParameterListAuxLoop:aloop{: Node resultado; 
																							if(aloop == null) {
																								resultado = (Node) a1;
																							}
																							else{
																								resultado = new Node();
																								resultado.addElement((Node)a1);
																								resultado.addAllElements(((Node) aloop).getElements());}
																							RESULT = resultado; :}																						} 
								|{: RESULT = null; :} ;

collectionKind ::= COLLECTION;



relationalOperator ::= EQ {: RESULT = "="; :}  
						| GREATERTHAN  {: RESULT = ">"; :} 
						| LESSTHAN {: RESULT = "<"; :} 
						| GREATEREQTHAN {: RESULT = ">="; :}  
						| LESSEQTHAN {: RESULT = "<="; :}  
						| NOTEQ {: RESULT = "<>"; :} ;



addOperator ::= PLUS {: RESULT = "+"; :}  
				| MINUS  {: RESULT = "-"; :} 
				| MOD {: RESULT = "%"; :} ;



multiplyOperator ::= MULTIPLY {: RESULT = "*"; :}  
					| DIVIDE {: RESULT = "/"; :}  
					| MOD {: RESULT = "%"; :} ;



unaryOperator ::= MINUS {: RESULT = "-"; :} | NOT {: RESULT = "not"; :} ;



logicalOperator ::= AND {: RESULT = "and"; :} 
					| OR {: RESULT = "or"; :} 
					| XOR {: RESULT = "xor"; :} 
					| IMPLIES {: RESULT = "implies"; :};



number ::= INTEGER_LITERAL:numbInt {: RESULT = new ConteudoObjeto("Integer", numbInt); :} | FLOAT_LITERAL:numbFloat {: RESULT = new ConteudoObjeto("Float", numbFloat); :};